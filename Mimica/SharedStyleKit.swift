//
//  SharedStyleKit.swift
//  Mimica
//
//  Created by Gleb LInnik on 23.08.17.
//  Copyright Â© 2017 Mimica. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class SharedStyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let mainGradientColor1: UIColor = UIColor(red: 0.988, green: 0.376, blue: 0.212, alpha: 1.000)
        static let mainGradientColor2: UIColor = UIColor(red: 1.000, green: 0.176, blue: 0.333, alpha: 1.000)
        static let loginButtonColor: UIColor = UIColor(red: 0.976, green: 0.290, blue: 0.251, alpha: 1.000)
        static let calendarCellBgColor: UIColor = UIColor(red: 0.969, green: 0.969, blue: 0.969, alpha: 1.000)
        static let calendarCellSelectedColor: UIColor = UIColor(red: 0.870, green: 0.870, blue: 0.870, alpha: 1.000)
        static let calendarCellBorderColor: UIColor = UIColor(red: 0.890, green: 0.890, blue: 0.890, alpha: 1.000)
        static let calendarCellTitleColor: UIColor = UIColor(red: 0.290, green: 0.290, blue: 0.290, alpha: 1.000)
        static let calendarCellDateColor: UIColor = UIColor(red: 0.643, green: 0.643, blue: 0.643, alpha: 1.000)
        static let loginViewBorderColor: UIColor = UIColor(red: 0.592, green: 0.592, blue: 0.592, alpha: 1.000)
        static let facebookColor: UIColor = UIColor(red: 0.231, green: 0.349, blue: 0.596, alpha: 1.000)
        static let twitterColor: UIColor = UIColor(red: 0.114, green: 0.631, blue: 0.949, alpha: 1.000)
        static let googleColor: UIColor = UIColor(red: 0.259, green: 0.522, blue: 0.957, alpha: 1.000)
        static let mainGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [SharedStyleKit.mainGradientColor2.cgColor, SharedStyleKit.mainGradientColor1.cgColor] as CFArray, locations: [0, 1])!
    }

    //// Colors

    @objc dynamic public class var mainGradientColor1: UIColor { return Cache.mainGradientColor1 }
    @objc dynamic public class var mainGradientColor2: UIColor { return Cache.mainGradientColor2 }
    @objc dynamic public class var loginButtonColor: UIColor { return Cache.loginButtonColor }
    @objc dynamic public class var calendarCellBgColor: UIColor { return Cache.calendarCellBgColor }
    @objc dynamic public class var calendarCellSelectedColor: UIColor { return Cache.calendarCellSelectedColor }
    @objc dynamic public class var calendarCellBorderColor: UIColor { return Cache.calendarCellBorderColor }
    @objc dynamic public class var calendarCellTitleColor: UIColor { return Cache.calendarCellTitleColor }
    @objc dynamic public class var calendarCellDateColor: UIColor { return Cache.calendarCellDateColor }
    @objc dynamic public class var loginViewBorderColor: UIColor { return Cache.loginViewBorderColor }
    @objc dynamic public class var facebookColor: UIColor { return Cache.facebookColor }
    @objc dynamic public class var twitterColor: UIColor { return Cache.twitterColor }
    @objc dynamic public class var googleColor: UIColor { return Cache.googleColor }

    //// Gradients

    @objc dynamic public class var mainGradient: CGGradient { return Cache.mainGradient }

    //// Drawing Methods

    @objc dynamic public class func drawFavebookButton(frame: CGRect = CGRect(x: 0, y: 0, width: 60, height: 60)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)


        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
        SharedStyleKit.facebookColor.setFill()
        ovalPath.fill()


        //// Facebook Drawing
        let facebookPath = UIBezierPath()
        facebookPath.move(to: CGPoint(x: group.minX + 0.62682 * group.width, y: group.minY + 0.25010 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.56198 * group.width, y: group.minY + 0.25000 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.37305 * group.height), controlPoint1: CGPoint(x: group.minX + 0.48913 * group.width, y: group.minY + 0.25000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.29830 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.42978 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.37687 * group.width, y: group.minY + 0.42978 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.36667 * group.width, y: group.minY + 0.43998 * group.height), controlPoint1: CGPoint(x: group.minX + 0.37123 * group.width, y: group.minY + 0.42978 * group.height), controlPoint2: CGPoint(x: group.minX + 0.36667 * group.width, y: group.minY + 0.43435 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.36667 * group.width, y: group.minY + 0.52218 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.37687 * group.width, y: group.minY + 0.53238 * group.height), controlPoint1: CGPoint(x: group.minX + 0.36667 * group.width, y: group.minY + 0.52782 * group.height), controlPoint2: CGPoint(x: group.minX + 0.37123 * group.width, y: group.minY + 0.53238 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.53238 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.73980 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.45225 * group.width, y: group.minY + 0.75000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44207 * group.width, y: group.minY + 0.74543 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44662 * group.width, y: group.minY + 0.75000 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.53732 * group.width, y: group.minY + 0.75000 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.73980 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54295 * group.width, y: group.minY + 0.75000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.74543 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.53238 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.62373 * group.width, y: group.minY + 0.53238 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.63393 * group.width, y: group.minY + 0.52218 * group.height), controlPoint1: CGPoint(x: group.minX + 0.62937 * group.width, y: group.minY + 0.53238 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63393 * group.width, y: group.minY + 0.52782 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.63397 * group.width, y: group.minY + 0.43998 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.63097 * group.width, y: group.minY + 0.43277 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63397 * group.width, y: group.minY + 0.43728 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63288 * group.width, y: group.minY + 0.43468 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.62375 * group.width, y: group.minY + 0.42978 * group.height), controlPoint1: CGPoint(x: group.minX + 0.62907 * group.width, y: group.minY + 0.43085 * group.height), controlPoint2: CGPoint(x: group.minX + 0.62647 * group.width, y: group.minY + 0.42978 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.42978 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.38168 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.58313 * group.width, y: group.minY + 0.34683 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54750 * group.width, y: group.minY + 0.35857 * group.height), controlPoint2: CGPoint(x: group.minX + 0.55302 * group.width, y: group.minY + 0.34683 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.62680 * group.width, y: group.minY + 0.34682 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.63700 * group.width, y: group.minY + 0.33662 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63243 * group.width, y: group.minY + 0.34682 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63700 * group.width, y: group.minY + 0.34225 * group.height))
        facebookPath.addLine(to: CGPoint(x: group.minX + 0.63700 * group.width, y: group.minY + 0.26030 * group.height))
        facebookPath.addCurve(to: CGPoint(x: group.minX + 0.62682 * group.width, y: group.minY + 0.25010 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63700 * group.width, y: group.minY + 0.25467 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63243 * group.width, y: group.minY + 0.25012 * group.height))
        facebookPath.close()
        facebookPath.usesEvenOddFillRule = true
        UIColor.white.setFill()
        facebookPath.fill()
    }

    @objc dynamic public class func drawTwitterButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 60, height: 60), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 60, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 60, y: resizedFrame.height / 60)


        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 30, y: 60))
        bezierPath.addCurve(to: CGPoint(x: 60, y: 30), controlPoint1: CGPoint(x: 46.57, y: 60), controlPoint2: CGPoint(x: 60, y: 46.57))
        bezierPath.addCurve(to: CGPoint(x: 30, y: 0), controlPoint1: CGPoint(x: 60, y: 13.43), controlPoint2: CGPoint(x: 46.57, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 0, y: 30), controlPoint1: CGPoint(x: 13.43, y: 0), controlPoint2: CGPoint(x: 0, y: 13.43))
        bezierPath.addCurve(to: CGPoint(x: 30, y: 60), controlPoint1: CGPoint(x: 0, y: 46.57), controlPoint2: CGPoint(x: 13.43, y: 60))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        SharedStyleKit.twitterColor.setFill()
        bezierPath.fill()


        //// Twitter Drawing
        let twitterPath = UIBezierPath()
        twitterPath.move(to: CGPoint(x: 48.93, y: 19.55))
        twitterPath.addCurve(to: CGPoint(x: 44.58, y: 20.74), controlPoint1: CGPoint(x: 47.57, y: 20.15), controlPoint2: CGPoint(x: 46.12, y: 20.56))
        twitterPath.addCurve(to: CGPoint(x: 47.91, y: 16.55), controlPoint1: CGPoint(x: 46.15, y: 19.8), controlPoint2: CGPoint(x: 47.34, y: 18.32))
        twitterPath.addCurve(to: CGPoint(x: 43.1, y: 18.39), controlPoint1: CGPoint(x: 46.45, y: 17.42), controlPoint2: CGPoint(x: 44.83, y: 18.05))
        twitterPath.addCurve(to: CGPoint(x: 37.57, y: 16), controlPoint1: CGPoint(x: 41.72, y: 16.92), controlPoint2: CGPoint(x: 39.75, y: 16))
        twitterPath.addCurve(to: CGPoint(x: 29.99, y: 23.57), controlPoint1: CGPoint(x: 33.38, y: 16), controlPoint2: CGPoint(x: 29.99, y: 19.39))
        twitterPath.addCurve(to: CGPoint(x: 30.19, y: 25.3), controlPoint1: CGPoint(x: 29.99, y: 24.17), controlPoint2: CGPoint(x: 30.06, y: 24.75))
        twitterPath.addCurve(to: CGPoint(x: 14.57, y: 17.38), controlPoint1: CGPoint(x: 23.89, y: 24.98), controlPoint2: CGPoint(x: 18.31, y: 21.97))
        twitterPath.addCurve(to: CGPoint(x: 13.55, y: 21.19), controlPoint1: CGPoint(x: 13.92, y: 18.5), controlPoint2: CGPoint(x: 13.55, y: 19.8))
        twitterPath.addCurve(to: CGPoint(x: 16.92, y: 27.5), controlPoint1: CGPoint(x: 13.55, y: 23.82), controlPoint2: CGPoint(x: 14.89, y: 26.14))
        twitterPath.addCurve(to: CGPoint(x: 13.49, y: 26.55), controlPoint1: CGPoint(x: 15.68, y: 27.46), controlPoint2: CGPoint(x: 14.51, y: 27.11))
        twitterPath.addLine(to: CGPoint(x: 13.49, y: 26.64))
        twitterPath.addCurve(to: CGPoint(x: 19.56, y: 34.07), controlPoint1: CGPoint(x: 13.49, y: 30.31), controlPoint2: CGPoint(x: 16.1, y: 33.37))
        twitterPath.addCurve(to: CGPoint(x: 17.57, y: 34.34), controlPoint1: CGPoint(x: 18.93, y: 34.24), controlPoint2: CGPoint(x: 18.26, y: 34.34))
        twitterPath.addCurve(to: CGPoint(x: 16.14, y: 34.19), controlPoint1: CGPoint(x: 17.08, y: 34.34), controlPoint2: CGPoint(x: 16.6, y: 34.29))
        twitterPath.addCurve(to: CGPoint(x: 23.22, y: 39.46), controlPoint1: CGPoint(x: 17.11, y: 37.21), controlPoint2: CGPoint(x: 19.9, y: 39.4))
        twitterPath.addCurve(to: CGPoint(x: 13.81, y: 42.69), controlPoint1: CGPoint(x: 20.62, y: 41.49), controlPoint2: CGPoint(x: 17.36, y: 42.69))
        twitterPath.addCurve(to: CGPoint(x: 12, y: 42.59), controlPoint1: CGPoint(x: 13.2, y: 42.69), controlPoint2: CGPoint(x: 12.59, y: 42.66))
        twitterPath.addCurve(to: CGPoint(x: 23.61, y: 46), controlPoint1: CGPoint(x: 15.35, y: 44.74), controlPoint2: CGPoint(x: 19.34, y: 46))
        twitterPath.addCurve(to: CGPoint(x: 45.17, y: 24.44), controlPoint1: CGPoint(x: 37.55, y: 46), controlPoint2: CGPoint(x: 45.17, y: 34.46))
        twitterPath.addLine(to: CGPoint(x: 45.14, y: 23.46))
        twitterPath.addCurve(to: CGPoint(x: 48.93, y: 19.55), controlPoint1: CGPoint(x: 46.63, y: 22.4), controlPoint2: CGPoint(x: 47.92, y: 21.07))
        twitterPath.close()
        twitterPath.usesEvenOddFillRule = true
        UIColor.white.setFill()
        twitterPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawGoogleButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 60, height: 60), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 60, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 60, y: resizedFrame.height / 60)


        //// Group 2
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 30, y: 60))
        bezierPath.addCurve(to: CGPoint(x: 60, y: 30), controlPoint1: CGPoint(x: 46.57, y: 60), controlPoint2: CGPoint(x: 60, y: 46.57))
        bezierPath.addCurve(to: CGPoint(x: 30, y: 0), controlPoint1: CGPoint(x: 60, y: 13.43), controlPoint2: CGPoint(x: 46.57, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 0, y: 30), controlPoint1: CGPoint(x: 13.43, y: 0), controlPoint2: CGPoint(x: 0, y: 13.43))
        bezierPath.addCurve(to: CGPoint(x: 30, y: 60), controlPoint1: CGPoint(x: 0, y: 46.57), controlPoint2: CGPoint(x: 13.43, y: 60))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        SharedStyleKit.googleColor.setFill()
        bezierPath.fill()


        //// Google Drawing
        let googlePath = UIBezierPath()
        googlePath.move(to: CGPoint(x: 45, y: 28.33))
        googlePath.addLine(to: CGPoint(x: 31, y: 28.33))
        googlePath.addLine(to: CGPoint(x: 31, y: 33))
        googlePath.addLine(to: CGPoint(x: 39.54, y: 33))
        googlePath.addCurve(to: CGPoint(x: 30, y: 40), controlPoint1: CGPoint(x: 38.27, y: 37.06), controlPoint2: CGPoint(x: 34.48, y: 40))
        googlePath.addCurve(to: CGPoint(x: 20, y: 30), controlPoint1: CGPoint(x: 24.48, y: 40), controlPoint2: CGPoint(x: 20, y: 35.52))
        googlePath.addCurve(to: CGPoint(x: 30, y: 20), controlPoint1: CGPoint(x: 20, y: 24.48), controlPoint2: CGPoint(x: 24.48, y: 20))
        googlePath.addCurve(to: CGPoint(x: 37.11, y: 22.97), controlPoint1: CGPoint(x: 32.78, y: 20), controlPoint2: CGPoint(x: 35.3, y: 21.13))
        googlePath.addLine(to: CGPoint(x: 40.5, y: 19.29))
        googlePath.addCurve(to: CGPoint(x: 30, y: 15), controlPoint1: CGPoint(x: 37.79, y: 16.63), controlPoint2: CGPoint(x: 34.09, y: 15))
        googlePath.addCurve(to: CGPoint(x: 15, y: 30), controlPoint1: CGPoint(x: 21.72, y: 15), controlPoint2: CGPoint(x: 15, y: 21.71))
        googlePath.addCurve(to: CGPoint(x: 30, y: 45), controlPoint1: CGPoint(x: 15, y: 38.28), controlPoint2: CGPoint(x: 21.72, y: 45))
        googlePath.addCurve(to: CGPoint(x: 45, y: 33), controlPoint1: CGPoint(x: 37.26, y: 45), controlPoint2: CGPoint(x: 43.61, y: 39.85))
        googlePath.addLine(to: CGPoint(x: 45, y: 28.33))
        googlePath.close()
        googlePath.usesEvenOddFillRule = true
        UIColor.white.setFill()
        googlePath.fill()
        
        context.restoreGState()

    }




    @objc(SharedStyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
